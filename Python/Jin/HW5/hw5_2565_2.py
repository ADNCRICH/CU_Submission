# -*- coding: utf-8 -*-
"""HW5_2565_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17U5Atlangz7CvWYCzwaXKXE1bc15uraD

# HW5_TSD: การบ้านครั้งที่ 5 เรื่อง Nested Loop, Nested List, Tuple/Set/Dict

**จุดมุ่งหมายของการบ้าน**
*   เข้าใจและสามารถใช้งาน Nested Loop & Nested List ได้
*   เข้าใจและสามารถใช้งาน List/Tuple/Set/Dict ได้

##**เริ่มต้น**
1. ให้ copy file ไปที่ Google Drive ของนิสิตโดยเลือกเมนู File->Save a copy in Drive
2. ไปที่ไฟล์ที่ copy มาแล้วตั้งชื่อไฟล์เป็น HW5_XXXXXXXXXX.ipynb เมื่อ XXXXXXXXXX คือรหัสนิสิต

## <font color=red>สำคัญ: อ่านตรงนี้ด้วย
## ข้อห้าม</font>
 - ห้าม import ใด ๆ
 - ในฟังก์ชันต้องไม่ใช้ตัวแปรนอกฟังก์ชัน
 - ฟังก์ชันต้องไม่ print อะไรใด ๆ ทั้งสิ้น
 - ห้ามเปลี่ยนบรรทัด `def` ของฟังก์ชันที่ให้เขียน
 - ในกรณีที่ฟังก์ชันมีการคืนค่า ฟังก์ชันต้องคืนข้อมูลและประเภทข้อมูลตามที่กำหนดเท่านั้น
 - ฟังก์ชันต้องไม่เปลี่ยนแปลงข้อมูลภายในของพารามิเตอร์ที่ได้รับ
 - บรรทัดแรกของ code cell ที่เขียนต้องขึ้นต้นด้วย `# HW5_TSD` ตามที่ให้ไป ห้ามแก้ไขหรือเพิ่มอะไรเข้าไปก่อนหน้า
 - อนุญาตให้มีการเขียนฟังก์ชันเอง แต่ต้องเขียนในบริเวณที่กำหนด

- <font color=red>ส่อทุจริต</font> เช่น
 - ส่งโปรแกรมที่ผู้ส่งไม่สามารถอธิบายได้ว่า ใช้หลักการและทำงานอย่างไร
  - หรือ ส่งโปรแกรมที่คล้ายกับโปรแกรมของผู้อื่นมาก ๆ (ไม่ว่าจะเป็นผู้ให้หรือผู้รับ จะตั้งใจหรือไม่ก็ตาม)
  - ฉะนั้น
    - ให้แน่ใจว่า ไม่ดูโปรแกรมของคนอื่น
    - ให้แน่ใจว่า ไม่ได้ให้คนอื่นดูโปรแกรมของตัวเอง

- หากพบว่า งานที่ส่งส่อทุจริต จะได้นิสิตจะได้ $0$ ใน <font color=red>การบ้านครั้งนี้ และการบ้านครั้งที่แล้ว ๆ</font>
- จะตรวจให้คะแนน เมื่อ
 - แฟ้มที่ส่งครั้งหลังสุดใน MyCourseVille เป็นแฟ้มที่ตั้งชื่อตามที่กำหนด และเป็นแฟ้มที่ได้จากการ File->Download->Download .ipynb เท่านั้น (ไม่ใช่แฟ้ม .py แล้วมา rename เป็น .ipynb)
 - ฟังก์ชันที่เขียนส่งต้องอยู่ใน code cell ที่ให้มาเท่านั้น
 - ไม่ทำในสิ่งที่ห้ามทำในข้อห้าม
 - code cell ที่ให้เขียนสามารถทำงานได้ (ไม่มี error)
 - ให้แน่ใจว่า code ที่ส่งมา ไม่มี syntax error, indentation error หรืออื่น ๆ ที่ทำให้สั่งทำงาน code ไม่ได้ (ถ้ามี ก็ตรวจไม่ได้ ได้ 0)

##**การส่งงาน**

1. ส่งไฟล์ในรูปแบบ .ipynb ที่ได้จากการเลือกเมนู File->Download->Download .ipynb ของ Colab และส่งแฟ้ม ipynb นี้ใน MyCourseVille
2. ตั้งชื่อไฟล์เป็น HW5_XXXXXXXXX.ipynb เมื่อ XXXXXXXXXX คือ รหัสนิสิต
3. ส่งแฟ้ม .ipynb กี่ครั้งก็ได้ แต่จะตรวจแฟ้ม .ipynb **แฟ้มล่าสุด ที่ส่งภายในกำหนด** เท่านั้น
4. <font color="red">**กำหนดส่ง คือ ก่อน 23:59 น. ของพุธที่ 5 เมษายน 2566**</font>

# การบ้านครั้งที่ 5 : Historical Olympic Games Data Analysis

ข้อมูลที่ใช้ในการบ้านนี้ เป็นข้อมูลการเข้าร่วมการแข่งขันของนักกีฬาทีมชาติต่าง ๆ ในโอลิมปิก ทั้ง Winter Olympic และ Summer Olympic ระหว่าง ปีค.ศ. 2000-2016 ที่กรองมาจาก "120 years of Olympic history: athletes and results Dataset" ใน Kaggle.com

**หมายเหตุ:** การแข่งขัน Winter Olympic จะจัดขึ้นทุก 4 ปี เช่นเดียวกับ Summer Olympic โดยจะสับหว่างกัน ดังนั้น Winter Olympic จะห่างจาก Summer Olympic 2 ปี เช่น ปี 2000 เป็น Summer Olympic ปี 2002 เป็น Winter Olympic เป็นต้น

รัน code cell ด้านล่างนี้ เพื่อ download ไฟล์ `athlete_events_2000-2016_cl.csv` และ `athlete_events_mock.csv`จาก Google Drive เข้ามาใน Colab
"""

# ! gdown --id 1Hka3OmRMyN6vBHVssUxMeD9k58TUWjur
# ! gdown --id 11fkwj3pNX4CqhQ2zDrRfs8-n6ASR-foW

"""ไฟล์ `athlete_events_2000-2016_cl.csv` นี้มีข้อมูลจำนวน `85,259 rows` และ `15 columns`
โดย แถวนอนแถวแรกเป็นหัวตาราง ดังรายการด้านล่างนี้

1. ID - หมายเลขประจำตัวนักกีฬา
2. Name - ชื่อนักกีฬา
3. Sex - เพศ M (ชาย) หรือ F (หญิง)
4. Age - อายุ
5. Height - ความสูง (ซม.)
6. Weight - น้ำหนัก (กก.)
7. Team - ชื่อทีม
8. NOC - National Olympic Committee รหัสประเทศ 3 ตัวอักษร
9. Games - ชื่อเกมส์
10. Year - ปี
11. Season - Summer หรือ Winter
12. City - ชื่อเมืองที่จัดการแข่งขัน
13. Sport - กีฬา
14. Event - ประเภทการแข่งขัน
15. Medal - เหรียญ (Gold, Silver, Bronze, NA)

แถวถัดมาที่เหลือเป็นข้อมูลรายละเอียดต่าง ๆ ของนักกีฬาที่เข้าแข่งขัน

ส่วนไฟล์ `athlete_events_mock.csv` เป็นไฟล์ข้อมูลที่มีโครงสร้างลักษณะเดียวกัน เพียงแต่ใส่ข้อมูลสมมติเพื่อใช้ในการทดสอบโปรแกรม

รัน code cell ด้านล่างนี้ เพื่ออ่านข้อมูลจากไฟล์ csv มาเก็บในตัวแปร `data` และ `data_mock` ซึ่งเป็น nested list
"""

import csv
fn = open('athlete_events_2000-2016_cl.csv', 'r', encoding='utf-8-sig')
data = list(csv.reader(fn, delimiter=','))
fn.close()

fn = open('athlete_events_mock.csv', 'r', encoding='utf-8-sig')
data_mock = list(csv.reader(fn, delimiter=','))
fn.close()

"""โดยแต่ละ element ในลิสต์ `data` เป็นลิสต์ที่มีข้อมูล 15 elements ดูตัวอย่างโดย รัน code cell ด้านล่างนี้"""

# print(len(data))
# print(data[0])
# print(data[1])
# print(data[2])

"""## **งานของคุณ**

จงเขียนฟังก์ชัน
1. [10 คะแนน] `convert_to_dict(data)`
เพื่อแปลงข้อมูลการเข้าร่วมการแข่งขันของนักกีฬาที่อยู่ในรูป nested list มาจัดเก็บใน nested dict ที่มี `Year` และ `NOC` เป็น key ตามลำดับ
  * `data` คือข้อมูลการเข้าร่วมการแข่งขันของนักกีฬาที่อยู่ในรูป nested list
  * คืนค่า nested dict ที่เก็บข้อมูลการเข้าร่วมการแข่งขันของนักกีฬา โดยให้ dict ชั้นนอกมี key เป็น `Year` มี value เป็น dict ที่มี `NOC` เป็น key และมี value เป็น list ของ dict ที่มี key เป็นชื่อ `columns ทั้ง 15 fields` และ value คือค่าต่าง ๆ ของนักกีฬาแต่ละคน ซึ่งมีโครงสร้างเช่นนี้
  ```
  { year:  {NOC: [ {'ID':..., 'Name': ..., ... }, ... ], ...}, ... }
  ```
  * ตัวอย่างผลลัพธ์ของ
  ```
    d = convert_to_dict(data)
    print(len(d['2000']['THA']))
    for i in range(5):
      print(d['2000']['THA'][i])
  ```
     จะคืนค่า

  ```
  68
{'ID': '21596', 'Name': 'Somchai Cimlum', 'Sex': 'M', 'Age': '24', 'Height': '179', 'Weight': '73', 'Team': 'Thailand', 'NOC': 'THA',
    'Games': '2000 Summer', 'Year': '2000', 'Season': 'Summer', 'City': 'Sydney', 'Sport': 'Boxing', 'Event': "Boxing Men's Middleweight", 'Medal': 'NA'}
{'ID': '27067', 'Name': 'Saipin Dejsaeng', 'Sex': 'F', 'Age': '23', 'Height': '159', 'Weight': '62', 'Team': 'Thailand', 'NOC': 'THA', 'Games': '2000 Summer',
    'Year': '2000', 'Season': 'Summer', 'City': 'Sydney', 'Sport': 'Weightlifting', 'Event': "Weightlifting Women's Middleweight", 'Medal': 'NA'}
{'ID': '31865', 'Name': 'Sujitra Ekmongkolpaisarn', 'Sex': 'F', 'Age': '23', 'Height': '172', 'Weight': '50', 'Team': 'Thailand', 'NOC': 'THA',
    'Games': '2000 Summer', 'Year': '2000', 'Season': 'Summer', 'City': 'Sydney', 'Sport': 'Badminton', 'Event': "Badminton Women's Singles", 'Medal': 'NA'}
{'ID': '31865', 'Name': 'Sujitra Ekmongkolpaisarn', 'Sex': 'F', 'Age': '23', 'Height': '172', 'Weight': '50', 'Team': 'Thailand', 'NOC': 'THA',
    'Games': '2000 Summer', 'Year': '2000', 'Season': 'Summer', 'City': 'Sydney', 'Sport': 'Badminton', 'Event': "Badminton Women's Doubles", 'Medal': 'NA'}
{'ID': '49680', 'Name': 'Arun Homraruen', 'Sex': 'M', 'Age': '30', 'Height': '174', 'Weight': '64', 'Team': 'Thailand', 'NOC': 'THA',
    'Games': '2000 Summer', 'Year': '2000', 'Season': 'Summer', 'City': 'Sydney', 'Sport': 'Sailing', 'Event': "Sailing Men's Windsurfer", 'Medal': 'NA'}
  ```
  ความหมายคือ ในปี 2000 ประเทศไทย (THA) ร่วมแข่งขันทั้งสิ้น 68 รายการ โดยพิมพ์รายละเอียดของการเข้าร่วมแข่งขัน 5 รายการแรก

---

2. [10 คะแนน] `get_medals_by_team(athletes_by_Year_NOC, year)`
  เพื่อทำตารางสรุปเหรียญของแต่ละประเทศ ในการแข่งขันในปีที่ระบุ
  * `athletes_by_Year_NOC` คือข้อมูลการเข้าร่วมการแข่งขันของนักกีฬาที่อยู่ในรูป nested dict (ผลลัพธ์จากข้อ 1)
  * `year` คือปีการแข่งขัน (เป็น string)
  * คืนค่า dict ที่เก็บสรุปเหรียญ โดยมี Key เป็น NOC และ Value เป็น tuple ที่เก็บจำนวนเหรียญ ทอง เงิน และ ทองแดง ตามลำดับ
  * ตัวอย่างผลลัพธ์ของ
  ```
  d = convert_to_dict(data)
  m = get_medals_by_team(d, '2000')
  print(len(m))
  print(m)
  ```
  จะคืนค่า


  ```
  200
  {'FIN': (3, 1, 1), 'NOR': (20, 4, 19), 'NED': (27, 29, 23), 'EGY': (0, 0, 0), 'ARG': (0, 17, 3), 'CUB': (18, 35, 12), 'CMR': (18, 0, 0), 'MEX': (1, 2, 3), 'ITA': (22, 14, 29), 'PAK': (0, 0, 0), 'AZE': (2, 0, 1), 'CAN': (4, 4, 23), 'USA': (130, 61, 51), 'AUS': (60, 69, 54), 'KUW': (0, 0, 1), 'MAS': (0, 0, 0), 'BRU': (0, 0, 0), 'SUD': (0, 0, 0), 'BRN': (0, 0, 0), 'UZB': (1, 1, 2), 'JPN': (5, 31, 8), 'ESP': (3, 19, 20), 'ETH': (4, 1, 3), 'SRI': (0, 1, 0), 'SYR': (0, 0, 0), 'MAR': (0, 1, 4), 'SWE': (4, 20, 8), 'RUS': (66, 67, 54), 'JOR': (0, 0, 0), 'CHN': (39, 23, 17), 'GER': (31, 23, 64), 'GBR': (22, 20, 12), 'UGA': (0, 0, 0), 'SLO': (3, 0, 0), 'TUR': (3, 0, 2), 'RSA': (0, 2, 3), 'GHA': (0, 0, 0), 'ALG': (1, 1, 3), 'SUR': (0, 0, 0), 'SOM': (0, 0, 0), 'LBA': (0, 0, 0), 'FRA': (22, 30, 14), 'PLW': (0, 0, 0), 'LTU': (2, 0, 15), 'BRA': (0, 12, 36), 'UKR': (3, 20, 12), 'IRI': (3, 0, 1), 'NGR': (6, 2, 0), 'GRE': (4, 6, 8), 'CRO': (1, 0, 9), 'DMA': (0, 0, 0), 'DEN': (18, 3, 4), 'ANG': (0, 0, 0), 'IRQ': (0, 0, 0), 'MDV': (0, 0, 0), 'NZL': (1, 0, 3), 'PER': (0, 0, 0), 'SCG': (11, 1, 13), 'HUN': (25, 24, 4), 'CIV': (0, 0, 0), 'CYP': (0, 0, 0), 'KAZ': (3, 4, 0), 'KGZ': (0, 0, 1), 'BAN': (0, 0, 0), 'KSA': (0, 1, 1), 'QAT': (0, 0, 1), 'LIB': (0, 0, 0), 'OMA': (0, 0, 0), 'PLE': (0, 0, 0), 'YEM': (0, 0, 0), 'UAE': (0, 0, 0), 'ROU': (27, 6, 13), 'BLR': (3, 8, 11), 'TTO': (0, 1, 1), 'ISL': (0, 0, 1), 'NIG': (0, 0, 0), 'DJI': (0, 0, 0), 'SVK': (2, 3, 1), 'GUY': (0, 0, 0), 'JAM': (0, 20, 3), 'BAR': (0, 0, 1), 'VEN': (0, 0, 0), 'CHI': (0, 0, 17), 'IOA': (0, 0, 0), 'AUT': (3, 1, 0), 'INA': (2, 4, 2), 'BAH': (6, 0, 5), 'SMR': (0, 0, 0), 'MOZ': (1, 0, 0), 'POR': (0, 0, 2), 'CZE': (2, 3, 4), 'IND': (0, 0, 1), 'BUL': (5, 6, 2), 'SUI': (1, 11, 2), 'BEL': (0, 3, 4), 'MLT': (0, 0, 0), 'LUX': (0, 0, 0), 'GBS': (0, 0, 0), 'TUN': (
      0, 0, 0), 'GEO': (0, 0, 6), 'ERI': (0, 0, 0), 'TKM': (0, 0, 0), 'MAD': (0, 0, 0), 'MRI': (0, 0, 0), 'EST': (1, 0, 2), 'ISR': (0, 0, 1), 'ARM': (0, 0, 1), 'KEN': (2, 3, 2), 'MGL': (0, 0, 0), 'KOR': (12, 26, 35), 'GUI': (0, 0, 0), 'CGO': (0, 0, 0), 'POL': (7, 10, 7), 'VIN': (0, 0, 0), 'TOG': (0, 0, 0), 'ECU': (0, 0, 0), 'SEY': (0, 0, 0), 'URU': (0, 1, 0), 'GEQ': (0, 0, 0), 'ANT': (0, 0, 0), 'BOT': (0, 0, 0), 'SKN': (0, 0, 0), 'PAN': (0, 0, 0), 'COM': (0, 0, 0), 'TAN': (0, 0, 0), 'COL': (1, 0, 0), 'ISV': (0, 0, 0), 'SLE': (0, 0, 0), 'LAT': (1, 1, 1), 'AND': (0, 0, 0), 'MON': (0, 0, 0), 'SWZ': (0, 0, 0), 'ARU': (0, 0, 0), 'MDA': (0, 1, 1), 'ZIM': (0, 0, 0), 'CRC': (0, 0, 2), 'GUA': (0, 0, 0), 'NEP': (0, 0, 0), 'PNG': (0, 0, 0), 'MKD': (0, 0, 1), 'GAB': (0, 0, 0), 'SGP': (0, 0, 0), 'IRL': (0, 1, 0), 'PHI': (0, 0, 0), 'BER': (0, 0, 0), 'PUR': (0, 0, 0), 'ZAM': (0, 0, 0), 'DOM': (0, 0, 0), 'BOL': (0, 0, 0), 'MLI': (0, 0, 0), 'PAR': (0, 0, 0), 'HON': (0, 0, 0), 'PRK': (0, 1, 3), 'HKG': (0, 0, 0), 'TPE': (0, 1, 4), 'MYA': (0, 0, 0), 'MAW': (0, 0, 0), 'GUM': (0, 0, 0), 'BHU': (0, 0, 0), 'THA': (1, 0, 2), 'SEN': (0, 0, 0), 'HAI': (0, 0, 0), 'IVB': (0, 0, 0), 'CAF': (0, 0, 0), 'LBR': (0, 0, 0), 'NCA': (0, 0, 0), 'BEN': (0, 0, 0), 'AHO': (0, 0, 0), 'MTN': (0, 0, 0), 'ESA': (0, 0, 0), 'CPV': (0, 0, 0), 'TJK': (0, 0, 0), 'BIH': (0, 0, 0), 'GAM': (0, 0, 0), 'LIE': (0, 0, 0), 'NAM': (0, 0, 0), 'RWA': (0, 0, 0), 'STP': (0, 0, 0), 'BDI': (0, 0, 0), 'CAM': (0, 0, 0), 'LCA': (0, 0, 0), 'SOL': (0, 0, 0), 'GRN': (0, 0, 0), 'SAM': (0, 0, 0), 'BIZ': (0, 0, 0), 'COD': (0, 0, 0), 'VAN': (0, 0, 0), 'LES': (0, 0, 0), 'LAO': (0, 0, 0), 'TGA': (0, 0, 0), 'ALB': (0, 0, 0), 'VIE': (0, 1, 0), 'CAY': (0, 0, 0), 'FSM': (0, 0, 0), 'ASA': (0, 0, 0), 'CHA': (0, 0, 0), 'FIJ': (0, 0, 0), 'BUR': (0, 0, 0), 'NRU': (0, 0, 0), 'COK': (0, 0, 0)}

  ```
  ความหมายคือ ในปี 2000 มีทีมเข้าแข่งขัน 200 ทีม (ประเทศ) ตามด้วยสรุปเหรียญทอง เงิน และ ทองแดง ของแต่ละทีม

---

3. [10 คะแนน] `get_top_five(medals)`
  เพื่อจัดอันดับประเทศ 5 อันดับแรก ที่ได้เหรียญมากที่สุด โดยเรียงจากจำนวนเหรียญทอง เหรียญเงิน และเหรียญทองแดงที่ได้ ตามลำดับ จากมากไปน้อย โดยพิจารณาที่จำนวนเหรียญทองเป็นลำดับแรก หากได้เหรียญทองเท่ากันจะพิจารณาจำนวนเหรียญเงินเป็นลำดับถัดมา หากทั้งจำนวนเหรียญทองและจำนวนเหรียญเงินเท่ากัน ให้พิจารณาจำนวนเหรียญทองแดงเป็นลำดับถัดไป

  * `medals` คือ dict ที่เก็บตารางสรุปเหรียญของแต่ละประเทศ (ผลลัพธ์จากข้อ 2)
  * คืนค่าลิสต์ของ tuple ที่เก็บ `(NOC,จำนวนเหรียญทอง, จำนวนเหรียญเงิน,จำนวนเหรียญทองแดง)` 5 อันดับแรก หากจำนวนเหรียญเท่ากันให้เรียงตามตัวอักษรของ NOC และหากอันดับที่ห้า มีประเทศมากกว่าหนึ่งประเทศได้จำนวนเหรียญเท่ากันให้เพิ่มประเทศที่มีจำนวนเหรียญเท่ากันเข้ามาให้หมด (top five จึงอาจมีมากกว่า 5 ประเทศ)

  * ตัวอย่างผลลัพธ์ของ
  ```
  d = convert_to_dict(data)
  m = get_medals_by_team(d, '2000')
  print(get_top_five(m))
  ```
  จะคืนค่า
  ```
  [('USA', 130, 61, 51), ('RUS', 66, 67, 54), ('AUS', 60, 69, 54), ('CHN', 39, 23, 17), ('GER', 31, 23, 64)]
  ```
  * ตัวอย่างผลลัพธ์ของ
  ```
  d_mock = convert_to_dict(data_mock)
  m_mock = get_medals_by_team(d_mock, '2010')
  print(get_top_five(m_mock))
  ```
  จะคืนค่า
  ```
  [('USA', 10, 0, 0), ('GER', 2, 0, 0), ('ESP', 0, 5, 0), ('FRA', 0, 5, 0), ('EGY', 0, 1, 2), ('ITA', 0, 1, 2), ('NCA', 0, 1, 2)]
  ```


---

4. [10 คะแนน] `get_medals_trend(athletes_by_Year_NOC, NOC, start, end)`
  เพื่อสรุปจำนวนเหรียญในแต่ละปีของประเทศ (NOC) ที่ระบุ โดยเรียงปีจาก ปีเริ่มต้นถึงปีสิ้นสุด
  * `athletes_by_Year_NOC` คือข้อมูลข้อมูลการเข้าร่วมการแข่งขันของนักกีฬาที่อยู่ในรูป nested dict (ผลลัพธ์จากข้อ 1)
  * `NOC` คือรหัสประเทศ (เป็น string)
  * `start` คือปี ค.ศ. เริ่มต้น (เป็น int)
  * `end` คือปี ค.ศ. สิ้นสุด (เป็น int)
  * คืนค่าลิสต์ของ tuple ที่เก็บ `(ปีการแข่งขัน,จำนวนเหรียญทอง, จำนวนเหรียญเงิน,จำนวนเหรียญทองแดง)`
  * ตัวอย่างผลลัพธ์ของ
  ```
  d = convert_to_dict(data)
  print('USA')
  print(get_medals_trend(d, 'USA', 2001, 2015))
  print('THA')
  print(get_medals_trend(d, 'THA', 2000, 2016))
  ```
  จะคืนค่า
  ```
  USA
[('2002', 11, 58, 15), ('2004', 117, 75, 71), ('2006', 9, 11, 32), ('2008', 127, 110, 80), ('2010', 12, 63, 22), ('2012', 145, 57, 46), ('2014', 10, 30, 24)]
  THA
[('2000', 1, 0, 2), ('2002', 0, 0, 0), ('2004', 3, 1, 4), ('2006', 0, 0, 0), ('2008', 2, 2, 0), ('2012', 0, 2, 1), ('2014', 0, 0, 0), ('2016', 2, 2, 2)]
  ```
**หมายเหตุ:**
  - start และ end ไม่อยู่นอกช่วงของข้อมูล (2000-2016)
  - แต่อาจจะเป็นเลขคี่ได้ ดังนั้นหาก start, end เป็น 2001, 2011 ให้แสดงข้อมูลของปี 2002 ถึง 2010
  - หากปีใดประเทศนั้นไม่ส่งนักกีฬาเข้าแข่งขันก็ให้ข้ามปีนั้นไป เช่น ตัวอย่างข้างต้น ประเทศไทย (THA) ไม่ได้ส่งนักกีฬาเข้าแข่งขันในปี 2010



---

5. [10 คะแนน] `get_sports(athletes_by_Year_NOC, NOC, year)`
  เพื่อสรุปเหรียญของแต่ละกีฬา ของประเทศและปีการแข่งขันที่กำหนด
  * `athletes_by_Year_NOC` คือข้อมูลข้อมูลการเข้าร่วมการแข่งขันของนักกีฬาที่อยู่ในรูป nested dict (ผลลัพธ์จากข้อ 1)
  * `NOC` คือรหัสประเทศ (เป็น string)
  * `year` คือปีการแข่งขัน (เป็น string)
  * คืนค่า set ที่เก็บประเภทกีฬา (Sport) ที่ได้เหรียญ
  * ตัวอย่างผลลัพธ์ของ
  ```
  d = convert_to_dict(data)
  print(get_sports(d, 'THA', '2000'))
  print(get_sports(d, 'THA', '2010'))
  print(get_sports(d, 'THA', '2020'))
  print(get_sports(d, 'SOM', '2000'))
  print(get_sports(d, 'THA', '2008'))
  print(get_sports(d, 'VIE', '2008'))
  print(get_sports(d, 'DEN', '2008'))
  print(get_sports(d, 'XXX', '2000'))
  ```
  จะคืนค่า

  ```
  {'Weightlifting', 'Boxing'}
  set()
  set()
  set()
  {'Weightlifting', 'Boxing', 'Taekwondo'}
  {'Weightlifting'}
  {'Swimming', 'Equestrianism', 'Rowing', 'Sailing', 'Cycling', 'Canoeing'}
  set()
  ```

---

6. [10 คะแนน] `get_common_sports(athletes_by_Year_NOC, NOCs, year)`
  เพื่อหาประเภทกีฬาที่กลุ่มประเทศที่สนใจ ได้เหรียญในประเภทกีฬาเดียวกันในปีการแข่งขันที่กำหนด
  * `athletes_by_Year_NOC` คือข้อมูลข้อมูลการเข้าร่วมการแข่งขันของนักกีฬาที่อยู่ในรูป nested dict (ผลลัพธ์จากข้อ 1)
  * `NOCs` คือเซตของรหัสประเทศที่สนใจ
  * `year` คือปีการแข่งขัน (เป็น string)
  * คืนค่า set ที่เก็บประเภทกีฬา (Sport) ที่ประเทศต่างๆ ในเซต `NOCs`ได้เหรียญในประเภทกีฬาเดียวกัน
  * ตัวอย่างผลลัพธ์ของ
  ```
  d = convert_to_dict(data)
  print(get_common_sports(d, {'THA','VIE'}, '2008'))
  print(get_common_sports(d, {'THA','VIE','DEN'}, '2008'))
  print(get_common_sports(d, {'THA','XXX'}, '2008'))
  ```
  จะคืนค่า
  ```
  {'Weightlifting'}
  set()
  set()
  ```
"""

# HW5_TSD (ไม่ลบหรือแก้ไขบรรทัดนี้ หรือเพิ่มอะไรก่อนบรรทัดนี้ โดยเด็ดขาด)
# ดูรายละเอียดและตัวอย่างเพิ่มเติมในคำอธิบายด้านบน


def convert_to_dict(data):
    athletes_by_Year_NOC = {}
    key = data[0]
    for i in data[1:]:
        if (i[9] not in athletes_by_Year_NOC):
            athletes_by_Year_NOC[i[9]] = dict()
        if (i[7] not in athletes_by_Year_NOC[i[9]]):
            athletes_by_Year_NOC[i[9]][i[7]] = []
        a = dict()
        for j in range(len(i)):
            a[key[j]] = i[j]
        athletes_by_Year_NOC[i[9]][i[7]].append(a)
    return athletes_by_Year_NOC


# ======================================
def get_medals_by_team(athletes_by_Year_NOC, year):
    medals = {}
    key = ["Gold", "Silver", "Bronze"]
    for i in athletes_by_Year_NOC[year]:
        if i not in medals:
            medals[i] = (0, 0, 0)
        a = list(medals[i])
        for j in athletes_by_Year_NOC[year][i]:
            for k in range(3):
                if j["Medal"] == key[k]:
                    a[k] += 1
        medals[i] = tuple(a)
    return medals


# ======================================
def get_top_five(medals):
    topfive = []
    from functools import cmp_to_key

    def cmp(a, b):
        if a[1] > b[1]:
            return -1
        elif a[1] == b[1]:
            if a[0] > b[0]:
                return 1
            else:
                return -1
        else:
            return 1
    cmpp = cmp_to_key(cmp)
    a = sorted(medals.items(), key=cmpp)
    cou = 0
    for i in a:
        if cou < 5 or (cou >= 5 and topfive[-1][1:] == i[1]):
            topfive.append(tuple([i[0]]+list(i[1])))
            cou += 1
        else:
            break
    return topfive


d_mock = convert_to_dict(data_mock)
m_mock = get_medals_by_team(d_mock, '2010')
print(get_top_five(m_mock))

# ======================================


def get_medals_trend(athletes_by_Year_NOC, NOC, start, end):
    trend = []
    ans = dict()
    key = ["Gold", "Silver", "Bronze"]
    for i in athletes_by_Year_NOC:
        if int(i) < start or int(i) > end:
            continue
        if NOC not in athletes_by_Year_NOC[i]:
            continue
        if i not in ans:
            ans[i] = [0, 0, 0]
        for j in athletes_by_Year_NOC[i][NOC]:
            for k in range(3):

                if j["Medal"] == key[k]:
                    ans[i][k] += 1
    for i in ans.items():
        trend.append(tuple([i[0]]+i[1]))
    trend.sort()
    return trend


# ======================================
def get_sports(athletes_by_Year_NOC, NOC, year):
    key = ["Gold", "Silver", "Bronze"]
    sports = set()
    if (year not in athletes_by_Year_NOC) or (NOC not in athletes_by_Year_NOC[year]):
        return set()
    for i in athletes_by_Year_NOC[year][NOC]:
        if (i["Medal"] in key):
            sports.add(i["Sport"])
    return sports


# ======================================
def get_common_sports(athletes_by_Year_NOC, NOCs, year):
    sports = set()
    ch = 1
    for i in NOCs:
        if ch == 1:
            sports = get_sports(athletes_by_Year_NOC, i, year)
            ch = 0
        else:
            sports.intersection_update(get_sports(athletes_by_Year_NOC, i, year))
    return sports


# ======================================
# สามารถเขียนฟังก์ชันที่สร้างเองได้ในบริเวณด้านล่างของ cell นี้ เท่านั้น

# d = convert_to_dict(data)
# print(len(d['2000']['THA']))
# for i in range(5):
#     print(d['2000']['THA'][i])

# d = convert_to_dict(data)
# m = get_medals_by_team(d, '2000')
# print(len(m))
# print(m)

# d_mock = convert_to_dict(data_mock)
# m_mock = get_medals_by_team(d_mock, '2010')
# print(get_top_five(m_mock))

# d = convert_to_dict(data)
# print('USA')
# print(get_medals_trend(d, 'USA', 2001, 2015))
# print('THA')
# print(get_medals_trend(d, 'THA', 2000, 2016))

# d = convert_to_dict(data)
# print(get_sports(d, 'THA', '2000'))
# print(get_sports(d, 'THA', '2010'))
# print(get_sports(d, 'THA', '2020'))
# print(get_sports(d, 'SOM', '2000'))
# print(get_sports(d, 'THA', '2008'))
# print(get_sports(d, 'VIE', '2008'))
# print(get_sports(d, 'DEN', '2008'))
# print(get_sports(d, 'XXX', '2000'))

# d = convert_to_dict(data)
# print(get_common_sports(d, {'THA', 'VIE'}, '2008'))
# print(get_common_sports(d, {'THA', 'VIE', 'DEN'}, '2008'))
# print(get_common_sports(d, {'THA', 'XXX'}, '2008'))
